import Page from "@reason/pages/Docs";
import DocLink from "@reason/components/DocLink";
export default Page({ title: "Codebase Overview" });

# Обзор кодовой базы

Протокол Mina написан на OCaml, статически типизированном, функциональном языке программирования.

Если вы новичок в OCaml, то вам может быть полезно изучить [Real World OCaml](https://realworldocaml.org/) для хорошего знакомства с языком, а также глубже погрузиться в узкие темы, если вам это интересно.
Если вы хорошо знакомы с OCaml, то вот дополнительная информация о том, как он используется в Mina Protocol.

## Структура кода

Посмотреть <DocLink copy="страницу репозитория структуры" url="/node-developers/directory-structure" />.

## Компиляция

Компилятор OCaml может быть нацелен на байт-код и нативную компиляцию. Наш код статически связывается с некоторыми библиотеками, так что он не может быть скомпилирован в байт-код. Также наш код не очень хорошо работает с REPL. Dune - наша система сборки. Dune имеет концепцию папок, представляющих модули в дополнение к каждому файлу, представляющему модуль. Если папка имеет файл с таким же именем, то это, по сути, эквивалентно `index.js` в Node.

У нас также есть файлы интерфейса в OCaml - они имеют расширение `.mli`, которое просто содержит подписи типа и структуры для модуля. Соответствующая реализация должна иметь то же имя файла, но с расширением `.ml`. Только то, что определено в интерфейсе, будет доступно из других модулей. Если для модуля не существует файла интерфейса, то всё отображается по умолчанию. _Примечание: язык программирования Reason следует тем же правилам с расширениями `.rei` и `.re`._

Для перехода на шаг соединения, `dune` использует `ldd` под капотом. Для оптимизации также можно использовать такие вещи, как `-O3`. Для отладки вы можете использовать `gdb`, который не полностью поддерживается OCaml, но работает. Предстоящий релиз OCaml (4.08) будет совместим с `gdb`.

## Документация

Основной трудностью при изучении OCaml является поиск и чтение документации для библиотек. Одной из библиотек, в частности, является библиотека `Core`, которая имеет следующую структуру:

```
              Base
               |
            Core_kernel -> Async_kernel
               |               |
    Unix  <-  Core  ->       Async
```

На самом деле существует несколько источников документации `Core` . Чтобы найти нужную документацию, для начала перейдите на GitHub, и воспользуйтесь поиском. Если вы не можете найти нужный модуль, перейдите в `Core_kernel`, а если это не помогло, то ищите `Base`. Также обратите внимание, что поиск не будет работать, если секции не будут расширены.

Вместо использования HTML документации, лучше применить встроенный редактор, который, с помощью такого инструмента, как `merlin`, предоставляет подсказки по типам. Недостатком, однако, является то, что Merlin будет работать только в том случае, если ваш код компилируется. Кроме того, он дает нам навигацию по коду в виде перехода к определению.

OPAM, который является пакетным менеджером для OCaml, обычно поставляет документацию с библиотеками. Доступ к этой документации можно получить через `merlin`.

## Расширения

В OCaml есть понятие плагинов компилятора, известное как ppx. Это обычный перехват, позволяющий компилировать временный код.

Примером расширения сигнатуры типа является следующее

```
    type t =
      | A
      | B [@ to_yojson f]

    [@@ deriving yojson]
```

В приведенном выше примере, одинарное `@` ограничивает расширение до одного выражения, а `@@` обозначает, что расширение будет увеличено в рамках вызывающего контекста.

Для расширения структуры или значения используется следующий синтаксис.

`%` возвращает значение/выражение.

`%%` вводит показания

```
    let x = [% ...]
    [%% ...]
    let y =
      let%... z = ... in
      match%... ... with
      | ...
      | ... in

    [%% if x]
      let x = y
    [%% else]
      let x = z
    [%% endif]
```

**TL;DR** Каждый раз, когда вы видите `[@ ...]` `[@@ ...]` `[% ...]` `[%% ...]` - это языковое расширение.

## Монады

Функциональные шаблоны дизайна, которые позволяют производить вычисления в очень общем виде, что устраняет необходимость в шаблоне кода. Монады позволяют нам абстрагироваться до более высокого уровня вычислений, являясь связующим элементом для нас. Другими словами, монады - это программируемые точки с запятой.

Рассмотрим следующий императивный пример:

```
    function example(x) {
      if ( x == null ) return null;
      x = x + 1;
      if ( !isEven(x) ) return null;
      return x;
    }
```

Это может быть аналогичным образом выражено в функциональном программировании с использованием монад, с помощью опции:

```
    type a' option =
      | None
      | Some of 'a

    let return x = Some x

    (* Bind infix operation, applies f to m *)
    let (>>=) m f =
      match m with
      | Some x -> f x
      | None   -> None

    (**
      Map infix operation
      Essentially the same as bind, but the inner function unwraps the value.
     **)
    let (>>|) m f = m >>= (fun x -> return (f x))
```

Теперь мы используем эти первоисточники для повторения приведенного выше императивного примера следующим образом:

```
    let add_one = ((+) 1)

    let bind_even : int -> int option =
      fun x -> if x mod 2 = 0 then Some x else None

    let example x = x >>| add_one >>= bind_even;

OCaml has a `ppx` that makes writing monads much easier to follow, using the let syntax.

    let%bind x = y in
      f x

    (* This compiles down to the following *)
    y >>= (fun x -> f x)
```

По сути, этот синтаксис берет значение из let-инструкции, помещает его слева от bind infix call, и помещает присвоение в lambda.

## Async

Под капотом Async использует монады, однако Ivar примитивны. `a' Ivar.t` - это, по сути, mutex, который можно заполнить только один раз. Как только значение из вычисления возвращается, оно затем заполняет Ivar. Остальной синтаксический сахар берет Ivar и пропускает их через `Deferred`-монады.

Существует функция `yield`, однако мы стараемся избегать ее использования, так как она имеет несколько странное поведение. Вместо этого мы обычно оперируем с обернутыми значениями, которые происходят между привязками `Deferred`.

Внимание: Еще одна функция, на которую стоит обратить внимание, это `Async.Pipe`, которая работает, по сути, как буфер. НЕ ИСПОЛЬЗУЙТЕ ЕЁ. Это небезопасно, так как по умолчанию она имеет неограниченную буферизацию (переполнение памяти), и немного странно себя ведет при выборе того, какой конец конвейера должен работать. Вместо этого используйте `Strict_pipe`, которая сворачивает конвейер, но даёт нам определённые гарантии относительно того, как его можно использовать. Еще один пользовательский помощник, который мы написали, это `Broadcast_pipe`, который позволяет одному конвейеру быть подключенным к нескольким последующим конвейерам. Кроме того, есть устаревшая команда `Linear_pipe`, которая была написана до того, как мы действительно смогли понять все подводные камни конвейера, и теперь вместо нее используются `Strict_pipe` и `Broadcast_pipe`.
