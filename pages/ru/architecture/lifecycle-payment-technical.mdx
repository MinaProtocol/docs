import Page from "@reason/pages/Docs";
import DocLink from "@reason/components/DocLink";
export default Page({ title: "Lifecycle of a Payment Technical Guide" });

# Жизненный цикл платежа - технический справочник

Платежи в Mina проходят через несколько этапов, прежде чем они считаются проверенными и завершенными. Этот документ предназначен для того, чтобы познакомиться с тем, что происходит с одним платежом, когда он проходит через кодовую базу. Если вы хотите понять, как платежи работают на макроскопическом уровне, доступен более высокий уровня обзора <DocLink copy="жизненного цикла платежа" url="/architecture/lifecycle-payment" />.

Допустим, вы хотите отправить платеж в Mina (при условии, что вами ранее уже был создан счет и вы получили необходимые средства).
Ваш друг даёт вам свой публичный ключ -- это `KEFLx5TOqJNzd6buc+dW3HCjkL57NjnZIaplYJ50DO1uTfogKfwAAAAA`.

Затем вы вызываете следующую команду:

```bash
$ mina client send-payment \
    -amount 10 \
    -receiver KEFLx5TOqJNzd6buc+dW3HCjkL57NjnZIaplYJ50DO1uTfogKfwAAAAA \
    -fee 3 \
    -privkey-path keys/my-wallet
```

Где:

- `amount` это сумма mina, которую вы посылаете
- `receiver` это публичный ключ предполагаемого получателя
- `fee` это комиссия, которая должна быть оплачена сети за обработку транзакции.
- `privkey-path` это путь к файлу с закрытым ключом для вашего аккаунта.

## Клиент Mina

Файл [client.ml](https://github.com/MinaProtocol/mina/tree/master/src/app/cli/src/client.ml) определяет парсер команд CLI для подкоманд `mina client`.
Мы часто используем стандартные библиотеки [Jane Street](https://github.com/janestreet).
В частности, очень часто используются [Core](https://opensource.janestreet.com/core/) (общие структуры данных) и [Async](https://opensource.janestreet.com/async/) (асинхронное программирование с использованием составного типа `Deferred.t`).
Поверх большинства файлов вы увидите какой-либо вариант `open Core` и `open Async`.
В [client.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/client.ml) мы тоже это видим. `Async` затеняет тип `Command` и позволяет нам декларативно отразить детали каждой команды.
Если вы прокрутите вниз [client.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/client.ml), вы увидите, что мы регистрируем команду `send-payment` в функции `send_payment`.
Здесь мы описываем флаги, от которых зависит это действие: `receiver` [публичного ключа](#public-key), комиссии, суммы и пути к вашему [приватному ключу](#private-key). Эти типы параметров флага определены в [daemon_rpcs.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/daemon_rpcs.ml).
В теле `send_payment` мы создаем платеж и пересылаем его [daemon](#daemon).

## Платеж

В [payment.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/payment.mli) вы увидите пару важных вещей. (1) мы разбиваем платежи на [платежную нагрузку](#payment-payload) (часть, которая должна быть [подписана](#signature)) и остальное. И (2) вы видите тип, который, хоть и определяется в странной манере, но является общим шаблоном в нашей кодовой базе.

См. более подробную информацию:

- <DocLink
    copy="Параметризованные отчеты"
    url="/developers/style-guide/#parameterized-records"
  />
- <DocLink copy="Ppx deriving" url="/developers/style-guide/#ppx_deriving" />
- <DocLink copy="Stable.V1" url="/developers/style-guide/#stable-v1" />
- <DocLink
    copy="Property based тесты"
    url="/developers/style-guide/#quickcheck-gen"
  />
- <DocLink
    copy="Typesafe Invariants"
    url="/developers/style-guide/#typesafe-invariants"
  />
- <DocLink copy="Unit Тесты" url="/developers/style-guide/#unit-tests" />

Давайте разберемся с платежной нагрузкой:

## Платежная нагрузка

Ознакомьтесь с разделом [payment_payload.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/payment_payload.mli). Напомним, что платежная нагрузка является частью платежа, который отправитель подпишет своим приватным ключом. Мы видим, что нагрузка строится из [публичного ключа](#public-key) получателя, [суммы](#currency), [комиссии](#currency), и [однократно используемого числа](#account-nonce). Опять же, полезная нагрузка содержит SNARK, поэтому она имеет `type var`, и другие важные функции со SNARK (в будущем RFC мы поместим это в пользовательскую [ppx_deriving](#ppx-deriving).

## Подписи

(TODO: @ihm can you correct any details I mess up here)

Мы используем [подписи Шнорра](https://en.wikipedia.org/wiki/Schnorr_signature). [Подпись Шнорра](https://en.wikipedia.org/wiki/Schnorr_signature) является элементом в [группе](https://en.wikipedia.org/wiki/Group_(mathematics). Наша группа - это точка на [эллиптической кривой](https://en.wikipedia.org/wiki/Elliptic_curve). Так что же такое подпись? Откройте [библиотеки подписи checked.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/checked.ml) и прокрутите до `module Signature` внутри `module type S`. Это ненулевая точка на кривой, также известная как пара двух значений `curve_scalar`. Для подписи мы даем [закрытый ключ](#private-key) и сообщение. Проверить подпись в сообщении можно с помощью [открытого ключа](#public-key).

Это первый раз, когда мы видим тяжело функторированный код, поэтому смотрите <DocLink copy="функторы" url="/developers/style-guide/#functors" />, если запутаетесь. Это также первый раз, когда мы видим пользовательскую схему SNARK. Для более подробной информации зайдите в раздел <DocLink copy="пользовательская схема SNARK" url="/developers/style-guide/#snark-checked" />.

## Приватный ключ

В разделе [private_key.ml] (https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/private_key.ml) мы видим закрытый ключ `Tick.Inner_curve.Scalar.t` или скаляр на эллиптической кривой. Давайте разберем его точнее: Так как мы полагаемся на [рекурсивные zkSNARK](https://eprint.iacr.org/2014/595), то на самом деле у нас есть две эллиптические кривые `Tick` и `Tock`. Большая часть нашей логики происходит внутри `Tick` (TODO: @ihm expand on this). [Подписи Шнорра](#signature) требуют, чтобы мы использовали скаляры для нашего приватного ключа.

## Открытый ключ

Открытый ключ, соответствующий [закрытому ключу] (#private-key) `p` - это просто $one^p$, или, другими словами, $one*one*one ....{p times}... one$. Мы можем увидеть это в [public_key.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/public_key.ml). Помните, что элементы группы являются ненулевыми точками кривой, поэтому мы также `include Non_zero_curve_point`.

Открытые ключи также можно сжимать -- см. [public_key.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/signature_lib/public_key.mli). Точка на эллиптической кривой может быть однозначно представлена одним элементом скалярного поля и boolean. Это представление мы используем в [платежной нагрузке](#payment-payload), так как оно более эффективно внутри схем SNARK.

## Валюта

В [currency.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/currency/currency.mli) мы определяем [номинальные типы](https://en.wikipedia.org/wiki/Nominal_type_system) комиссии, сумму и баланс, которые корректно обрабатывают overflow и underflow. На данный момент все поддерживается 64-битными беззнаковыми числами. Обратите внимание, что мы снова включаем операции схемы SNARK с [проверкой](#snark-checked) подмодулей внутри каждого из типов.

## Аккаунт

Платежи проводятся успешно только в том случае, если счет отправителя обладает определенными свойствами (и при этом баланс получателя не переполняется).

Согласно [account.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/account.ml), аккаунт - это запись с [публичным ключом](#public-key) (владельца учетной записи), [балансом](#currency), [однократно используемым числом nonce](#account-nonce), и [хэшем цепи поступлений](#receipt-chainh-hash).

Платеж действителен, если:

1. Подпись соответствует w.r.t. открытого ключа отправителя.
2. Отправитель имеет достаточно средств, чтобы произвести выплату комиссионного вознаграждения и суммы.
3. У получателя достаточно места для суммы s.t. переполнения не будет.
4. Показатель [nonce аккаунта](#account-nonce) совпадает с показателем nonce внутри платежа.

Когда мы производим платеж, мы также сохраняем его в [цепочке получения] (#receipt-chain-hash), и при этом увеличиваем параметр account nonce.

Комиссии обрабатываются статически (см. систему превышения комиссии)(#fee-excess).

Это закодировано внутри SNARK в [transaction_snark.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/transaction_snark/transaction_snark.ml), а именно в функции `apply_tagged_transaction`, хотя вам придется посмотреть, как устанавливаются флаги bool в случае `is_normal`.

It's captured outside the SNARK here: (TODO: where is this? Staged_ledger somewhere?)

### Account Nonce

[Account_nonce.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_numbers/account_nonce.mli) - это просто [номинальный тип](https://en.wikipedia.org/wiki/Nominal_type_system) вокруг натурального числа. Это используется для защиты от двойного использования платежей.
Account nonce увеличивается в учетной записи отправителя всякий раз, когда платеж применен.

### Хэш цепи получения

Хэш цепи получения [receipt.mli](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_base/receipt.mli) является верхним хэшем [списка Меркла](#merkle-list) платежных нагрузок. Он используется, чтобы доказать, что вы на самом деле сделали платеж кому-то. Так как Mina не ведет историю платежей, это то, как вы можете доказать кому-то, что ваш платеж прошел.

Как это работает?

Лист Меркла подобен [дереву Меркла](https://en.wikipedia.org/wiki/Merkle_tree), но с одним ответвлением. До тех пор, пока вы храните хэши листа Меркла, вы можете доказать, что любой отдельный фрагмент данных был частью списка, если вы точно знаете, что такое верхний хэш.

Если важно доказать, что ваш платеж прошел, вы просите получателя начать записывать хеши цепочки получения, а также передаете ему вашу платежную нагрузку. Затем он может проверить верхний хэш своей цепочки получения, чтобы узнать, включает ли он вашу платежную нагрузку.

## Сделайте перерыв!

Мы полностью описали все компоненты `Payment.t`. Поздравляем с тем, что вы зашли так далеко!

После перерыва мы будем готовы погрузиться в код daemon.

## Daemon

Daemon Mina определен в строке [mina.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina.ml). Ищите функцию `daemon`, чтобы увидеть CLI-флаги, которые мы там используем. Клиент может опционально автоматически запускать Daemon, если он уже существует. Мы получаем конфигурацию из конфигурационного файла JSON (попробуйте сначала из `-f`, затем из `$XDG_CONFIG_DIR/mina/daemon.json`, затем из `/etc/mina/daemon.json`). Перед этим мы производим множество настроек, которые приводят к вызову `Mina_main.Mina.Make`, а затем запускаем его командой `Run`. Подробности описаны ниже.

Имея модуль `Run`, мы можем создать экземпляр mina daemon на уровне значений, а также настроить любые фоновые процессы и сервисы.

## Main

К тому времени, как вы это читаете, надеемся, вам уже удалось приручить зверя, которым является [mina_main.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina_main.ml). Здесь мы соединяем систему на модульном уровне. Что это значит? Мы инстанцируем все функторы для различных подкомпонентов daemon. В конце концов, мы создаем что-то, что соответствует `Main_intf` (в этом же файле).

### Запуск функтора

В конце [mina_main.ml] (https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina_main.ml) мы определяем функтор `Run`, который, наконец, имеет другую сторону вызова `rpc`, который клиент осуществляет для `send_payment`. Run содержит исполнение на стороне сервера всех вызовов RPC, которые делает клиент. Он также отвечает за логику настройки любых RPC/веб-серверов и фоновых процессов.

Давайте предположим, что у нас есть уже созданный экземпляр `Run.t`, и мы вернемся к нему позже.

### Client_rpc

В [daemon_rpcs.ml] (https://github.com/minaprotocol/mina/tree/master/src/lib/daemon_rpcs/daemon_rpcs.ml) мы определяем конкретные вызовы RPC, которые клиент использует для связи с daemon. Для этого мы используем RPC-библиотеку [Async](https://opensource.janestreet.com/async/). `Send_payments` определяет вызов RPC, который мы используем для отправки платежа: тип запроса (ввод) -- платежи, которые мы хотим отправить -- и ответ (вывод) -- в данном случае `unit`, потому что мы не получаем никакой значимой обратной связи, кроме сообщения "платеж был запрошен" в случае успеха.

### График платежей в пул транзакций

Возвращаясь в [mina_main.ml](https://github.com/minaprotocol/mina/tree/master/src/app/cli/src/mina_main.ml), мы вызываем `send_payment` в [Run](#run), который делегирует `schedule_payment` -- здесь мы заносим платеж в [пул транзакций](#transaction-pool).

## Mina_lib

Для создания экземпляра `Run` нам нужно зайти в [mina_lib.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/mina_lib/mina_lib.ml), где мы соединим все подсистемы вместе на уровне значений. Это контрастирует с [mina_main.ml](#main), где мы соединяем все подсистемы вместе на уровне модулей.

Здесь мы можем проследить путь платежа из пула транзакций. Давайте сделаем набросок, прежде чем углубиться в каждую из подсистем:

1. [Пул транзакций](#transaction-pool) передает диффы от пула транзакций до [сети](#network).
2. [Автор предложения](#proposer) считывает платежи из пула транзакций, когда наступает время перехода из одного состояния блокчейна в другое. Эти платежи являются частью диффа для обновления [распределенного реестра](#stage-ledger), который предназначен для работы в новом состоянии блокчейна. Эмитируются [внешние переходы](#external-transition).
3. [Cеть](#network) и [автор предложения](#proposer) питают [внешние переходы](#external-transition), содержащие информацию об обновлении [распределенного реестра](#stage-ledger), при этом новый платеж буферизируется на [контроллер строителя реестра](#ledger-builder-controller).
4. [Контроллер строителя реестра](#ledger-builder-controller) выясняет, где [внешний переход](#external-transition) вписывается в дерево возможных форков. Если это расширяет наш "лучший" путь (состояние, cсогласно которому мы сделаем предложение позже), тогда мы делаем дорогостоящий шаг по материализации [вершины](#tip), удерживающей новый [распределенный реестр](#stage-ledger) и выпускаем эту сильнейшую вершину через [сеть](#network). Надежные клиенты передают только те вершины, которые они локально считают самыми сильными.

## Пул транзакций

Откройте [transaction_pool.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/transaction_poll/transaction_pool.ml)... TODO

## Сеть

TODO

## Автор предложения

TODO

## Внешний переход

TODO

## Контроллер строителя реестра

TODO

## Распределенный реестр

Распределенный реестр может рассматриваться как "База данных отложенных счетов", в которую занесены операции (платежи, монетная база и комиссии за доказательства), для которых еще нет ни одного SNARK.
Распределенный реестр состоит из состояния счетов (то, что мы сейчас называем реестром) и структуры данных (называемой [parallel_scan.ml](https://github.com/minaprotocol/mina/tree/master/src/lib/parallel_scan/parallel_scan.ml)). В нем отслеживаются все транзакции, которые должны получить SNARK (grep для `Available_job.t`), с целью получения SNARK отдельной транзакции, который бы подтверждал набор транзакций. Это выдается в распределенном реестре как Aux.
Параллельное сканирование представляет собой дерево, подобное структуре, которое хранит операции, которые должны быть подтверждены. Операция может заключаться в применении одной транзакции `Base` или в составлении других операций `Merge`. Снаркинг этих операций делегируется снарк-работникам. Снарк-работники подают SNARK для соответствующих операций, которые используются автором предложения для обновления состояния параллельного сканирования.

Когда автор предложения выигрывает блок, платежи, считанные из пула транзакций, отправляются в распределенный реестр для создания диффа `Staged_ledger_diff`.
Дифф состоит из:

1. Платежи, включенные в блок
2. Список доказательств, подтверждающих некоторые операции (платежи, монетная база и комиссии за доказательства) из предыдущих блоков
3. Монетная база

В распределенном реестре есть две основные операции.

1. Создание диффа :
   Чтобы включить платеж из пула транзакций, автор предложения должен добавить снарки, сгенерированные его собственными снарк-работниками (или же купить их у кого-нибудь), которые удостоверяют некоторые из транзакций, добавленных в предыдущих блоках. Количество снарков должно быть в два раза больше количества транзакций, включаемых в блок (инвариант структуры aux data). Эти доказательства включаются в дифф наряду с платежами и монетной базой.
   Затем diff включается во внешний переход и передается в сеть.

2. Применение диффа: Диффы от самой ноды (Внутренние переходы) или от сети (Внешние переходы) затем используются для обновления распределенного реестра путем внесения платежей в реестр и обновления состояния параллельного сканирования с доказательствами. Применение диффа может произвести проверку последовательности транзакций, которые были включены в предыдущие блоки.

## Реестр

TODO
