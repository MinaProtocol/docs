import Page from "@reason/pages/Docs";
import DocLink from "@reason/components/DocLink";
export default Page({ title: "How snapps work" });

# How snapps work

<Alert kind="info">

Snapps run in the latest versions of <a href="https://www.google.com/chrome/index.html">Chrome</a>, <a href="https://www.mozilla.org/en-US/firefox/new/">Firefox</a>, <a href="https://www.microsoft.com/edge">Edge</a>, and <a href="https://brave.com/">Brave</a> currently. We intend to add support for Safari in the future.
</Alert>

<br />

Snapps are written in TypeScript using the Snapp CLI. In the upcoming section, <DocLink copy="How to write a snapp" url="/snarky" />, we’ll go into detail about writing your first snapp. For now, we’ll discuss how snapps work.

A “snapp” consists of two parts: 1.) a smart contract and 2.) a UI (user interface) for users to interact with it. 

<img src="/static/img/docs-images/snapp-ui.png" width="40%"/>

<br />

<Alert kind="Tip">

We use the term <b>“smart contract”</b> to refer to the code written with SnarkyJS (which will be introduced below).

We use the term <b>“snapp”</b> to refer to the UI + the smart contract.
</Alert>

### Zero-knowledge based smart contracts

Because Snapps are based on zero-knowledge proofs (zk-SNARKs), a snapp developer writes what is called a **“circuit”**, which is the method from which a **prover function** and a corresponding **verifier function** are derived during the build process.

The **prover function** is the function which executes a smart contract’s custom logic. 

The **prover function** runs in a user’s web browser as part of the snapp. When interacting with a Snapp UI, users will enter any data (e.g. “buy ABC for y price”) required as input to the prover function, which will then generate a zero-knowledge proof.

<img src="/static/img/docs-images/prover-function.png" width="90%" />

Both **private inputs** and **public inputs** represent data that must be provided to the prover function when it runs in the user’s web browser.

**Private inputs** are not needed again after that point. But **public inputs** must be also provided to the verifier function (to be introduced soon) when it runs on the Mina network, and as such should never be used for data that you want to remain private.

The **verifier function** is the function that validates whether a zero-knowledge proof successfully passes all the constraints defined in the prover function. This always runs quickly and efficiently irrespective of the prover function’s complexity.

Within the Mina network, Mina acts as the verifier and runs the verifier function. We’ll describe how this works soon.

<img src="/static/img/docs-images/verifier-function.png" width="85%" />

### Mina’s Prover Function & Verifier Key

When a snapp developer writes their smart contract and runs `npm run build`, the build process outputs `smart_contract.js`. From this, you can run your prover function or generate a verification key, which you will need to run or deploy your smart contract, respectively.

The **prover function** runs in a user’s web browser. 

The **verification key** lives on chain for a given snapp account and is used by the Mina network to verify that a zero-knowledge proof has met all constraints defined in the prover. A verification key is required in order to create a snapp account. We will describe this more below.

The next two sections will go into more detail about how the prover and verifier functions are used when a Snapp is deployed and when users interact with a Snapp.

### Deploying a smart contract

<img src="/static/img/docs-images/smart-contract.png" width="55%" />

To deploy a smart contract, means to put it on Mina network.  To do this, the developer uses Snapp CLI. The deployment process sends a transaction containing the verification key to an address on the Mina blockchain. 

When a Mina address contains a verification key, it acts as a **snapp account**. 
Whereas a regular Mina account can receive any transactions, a snapp account can only successfully receive transactions containing a proof that satisfies the verifier function. Any transactions that do not pass the verifier function will be rejected by the Mina network.

<Alert kind="info">

When you deploy to a new Mina address, the Mina Protocol will charge a 1 MINA fee for account creation. This is unrelated to Snapps and is to help prevent sybil or denial of service attacks.
</Alert>

### Deploying a Snapp UI

<img src="/static/img/docs-images/mycoolsnapp.png" width="55%" />

Developers usually build a UI to allow users to interact with the smart contract.

Typically, this is a static website deployed to a host of the developer’s choosing. We recommend web hosts that offer a global CDN to ensure the best user experience.

Your website needs to contain the `smart_contract.js` file that was generated when building your smart contract. On the [How to Write a Snapp]() page, we will go into more detail.

<img src="/static/img/docs-images/submit-transaction-network.png" width="95%" />

### How users interact with the Snapp











Here you can find documentation on how to use **snarky**, a DSL for using zk-SNARKS, as well as **snarkyjs-crypto** a companion JavaScript library providing a suite of cryptographic primitives suitable for use with **snarky**.

## The structure of a SNAPP

A SNAPP (or snarkified app) has two parts:

## An example app

Let's build a simple app for proving we know a pre-image to a hash function.
You can find the completed app [here](https://github.com/o1-labs/sfbw-workshop/tree/master/solutions/ex_preimage).

### Building the SNARK

This first step in building our SNAPP is to define our SNARK. In this case, our SNARK
will prove, given a hash value **h**

> I know a field element **x** such that **hash(x) = h**.

where **hash** is the Poseidon hash function provided in snarky-universe.

The snarky component -- [defined in this file](https://github.com/o1-labs/sfbw-workshop/blob/master/solutions/ex_preimage/ex_preimage.re) -- is as follows:

```reasonml
module Universe = (val Snarky_universe.default());
open! Universe.Impl;
open! Universe;

let input = InputSpec.[(module Hash)];

module Witness = Field;

let main = (preimage: Witness.t, h, ()) =>
  Field.assertEqual(Hash.hash([|preimage|]), h);

runMain(input, (module Witness), main);
```

Let's break down this file bit by bit. The top 3 lines

```reasonml
module Universe = (val Snarky_universe.default());
open! Universe.Impl;
open! Universe;
```

are just a preamble which brings in scope all the functions we need. It uses the "default" SNARK construction backend,
which is the Groth16 SNARK instantiated using the bn128 curve.

The next line

```reasonml
let input = InputSpec.[(module Hash)];
```

declares that the public input to our SNARK will be a hash. The "public input" (or "statement") is the value that our
SNARK is checked against.

The next line

```reasonml
module Witness = Field;
```

states that our top-level "witness" (that is, the thing we're proving we know) will be a single field element,
as described above.

Next, we have the `main` function, which really defines our SNARK

```reasonml
let main = (preimage: Witness.t, h, ()) =>
  Field.assertEqual(Hash.hash([|preimage|]), h);
```

Here we write just what we described above: `main` computes the hash of the witness and asserts that it is
equal to the public input `h`.

The arguments to `main` must be

1. The top level witness value.
2. Any public inputs. Here we just have one, `h`.
3. A dummy `()` argument.

The final line

```reasonml
runMain(input, (module Witness), main);
```

sets up our program to work with the Node.js API.

### Using the SNARK

Now we're ready to use our SNARK. We're going to use the Node.js API.

The API is fairly straightforward. We can create a "snarky" object which has 2 methods:

1. `prove`, which takes a statement and a witness and returns a promise of a proof.
2. `verify`, which takes a statement and a proof and returns a promise of a bool.

Here is how it all comes together:

```javascript
const { bn128 } = require("snarkyjs-crypto");
const Snarky = require("snarkyjs");
const snarky = new Snarky("./ex_preimage.exe");

const preImage = bn128.Field.ofInt(5);
const statement = bn128.Hash.hash([preImage]);

snarky
  .prove({
    statement: [statement],
    witness: preImage,
  })
  .then((proof) => {
    console.log("Created proof:\n" + proof + "\n");
    return snarky.verify({
      statement: [statement],
      proof: proof,
    });
  }, console.log)
  .then(
    (verified) => {
      console.log("Was the proof verified? " + verified);
      if (verified) {
        process.exit(0);
      } else {
        process.exit(1);
      }
    },
    () => {
      process.exit(1);
    }
  );
```
